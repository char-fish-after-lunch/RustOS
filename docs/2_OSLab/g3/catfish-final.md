# RustOS多核移植与基于PARD框架的线程级Label管理 结果报告

2015011251 王纪霆

## 实验目标

以下是原定的实验目标以及目前完成的情况：

- 完成RustOS在riscv32上的多核开启（完成）
- 使RustOS可在中科院计算所PARD RISCV硬件环境下运行（部分完成）
- 使RustOS能够在PARD上开启smp（部分完成）
- 添加控制功能，使得RustOS可以控制/查看PARD的寄存器（未开始）

现在虽然在仿真环境下可以正常运行，但在zedboard硬件上还不能工作，并且原因不明。因此，可以说距离目标还相差很远。

## 实验内容

完成了以下的工作：

### 硬件

本质上，PARD直到10月30日放出最新稳定版本，才真正处于可用状态。因此也可以说此时工作才真正开始。由于PARD工作在RV64G指令集下，而Rust到RV64的编译器还无头绪，因此做了PARD到RV32G的适配。

这其中，对control plane本身的改动很小，仅需改动membase/memmask两个寄存器字长变化导致的细微兼容问题。而PARD所基于的rocket chip本身是同时支持32位与64位的，理论上仅需修改编译配置即可切换到32位。

但实际上却出现了不少细节上需要修补的问题。比如

+ 由于原本的硬件地址映射将DRAM地址安排在了0x100000000以后的位置，超出了rv32的地址长度，因此需要重新安排地址映射，移到相对较低的位置。与之对应的，也需要修改仿真DRAM的设置等与之对应。
+ 字长的改动导致总线出口的宽度发生变化，与之对应的zynq AXI4 IP核也要做设置上的调整。

以上结束后，硬件上的调整就差不多结束了，然而还有更多的问题。

### 软件

在前几周，连同wrj同学完成了RISC-V smp的初步实现，包括：

+ 使用C手动编写原子库，绕过Rust的原子指令bug；
+ 修改AtomicBool宽度，之后被wrj同学用直接在系统库里打patch的方式更彻底地修复；
+ 修改riscv-pk，完成rv32的启动过程，但之后的进程调度由wrj同学接手。

在此基础上开始试图使用硬件跑RustOS，先后解决了以下问题：

+ rocketchip产生的dtb(device tree blob)中的CPU属性不被bbl识别；
+ 软硬件使用的串口协议不一致；
+ bss段需要在初始化时手动清零；
+ 原本将内核栈和堆空间都放在了bss段，但前者放在bss段会导致错误，后者放在bss段会导致启动缓慢并且没有必要。将这两者移到了data段。
+ 页机制的适配问题：rocketchip实现的是简化的页机制，即硬件不去设dirty和access位，而是在发现这两个标记位和访问行为不一致时（执行访问但access=0；执行写入但dirty=0）报page fault，希望让中断响应去标注标记位。riscv priv1.10也写了允许这种实现，但目前的RustOS不能处理这个问题。目前的补救方式是将这两个位常设为1.
+ 原子指令的实现问题，riscv spec v2.2中说明lr.w, sc.w之间不允许出现其他访存操作，而之前的实现则不符合这个约束。

以上的最后几个问题都是和硬件实现严密相关的bug，因此确定位置和找出原因花费了很多时间。均修复之后，可以在仿真环境下完成RustOS启动了。

然而，依旧无法让RustOS在zedboard上启动。可能是其他IP核配置的问题，或是启动脚本等处导致的。

## 后期工作

离在物理板子上运行RustOS可能只差一步了。接下来打算向yzh老师请教，继续研究一下来解决这个问题。

之后是正式使用PARD机制，这需要：

+ 在riscv-pk中添加设备的识别
+ prm-sw中添加支持：监视两个串口，将两个串口的信息互相传递
+ RustOS中添加支持：增加相关系统调用，在切换进程时也告知底层硬件

如果能够在板子上成功运行，那么之后就都是软件工作了，可能会轻松很多。

## 总结和感想

这段时间在这项工作中还是投入了相当多的精力的。和之前做过的Project不同，这次的项目是在不稳定、缺乏文档的硬件上，用不稳定的工具链，开发一个不稳定的操作系统。因此，前期的调研和bug的调试都花费了很多时间。和起初预料的一样，遇到了很多问题，并没有能够取得顺利的进展。不过在麻烦的硬件软件对接结束之后，后续的工作可能会更加顺利。